// bmp2src - tool for converting 4/8/24 bit BMP image generated by Irfanview
// to C source file for AVR/STM32/ESP8266 and other MCUs
// Supported: 16-bit mode, 4 and 8-bit with palette
// 2016.12.23 Pawel A. Hernik

#include <stdio.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define RGBto565(r,g,b) ((((r) & 0xF8) << 8) | (((g) & 0xFC) << 3) | ((b) >> 3))

// -------------------------------------------------------------------
int main( int argc, char ** argv )
{
  if( argc != 2 )
  {
    fprintf( stderr, "Got %d args.\nUSAGE: bmp2src image.bmp >srcfile.h\n", argc );
    return -1;
  }
  int i, x, y, j;
  int w, h, bits;
  char *filename = argv[1];
  FILE * f = fopen( filename, "rb" );
  if( !f ) {
    fprintf( stderr, "ERROR: Cannot open file.\n" );
    return -11;
  }
  fseek(f,0,SEEK_END);
  int filesize = ftell(f);
  fseek(f,0,SEEK_SET);
  //printf("BMP: %ld\n",filesize);

  uint8_t *bmp = malloc(filesize);
  if(!bmp) {
    fprintf(stderr, "ERROR: Cannot allocate %d bytes\n",filesize);
    exit(1);
  }
  long res = fread( bmp, 1, filesize, f );
  if( res != filesize ) {
    fprintf(stderr, "ERROR: Read bytes %d!=%d\n",res,filesize);
    return -5;
  }
  fclose(f);

  w = bmp[18]+(bmp[19]<<8);
  h = bmp[22]+(bmp[23]<<8);
  bits = bmp[28]+(bmp[29]<<8);
  if(bits==24) bits=16;
  long colors = bits>8 ? 1<<bits : bmp[46]+(bmp[47]<<8);
  long offs = bmp[10]+(bmp[11]<<8)+(bmp[12]<<16);
  long bmpsize = w * h;
  if(bits==4) bmpsize/=2;
  if(bits==16) bmpsize*=2;
  printf("// Generated by bmp2src by Pawel A. Hernik\n");
  printf("// Generated from: %s\n", filename);
  printf("// Dimensions    : %dx%dx%d (%d colors)\n",w,h,bits,colors);
  printf("// Size          : %d [0x%04x] bytes\n\n",bmpsize,bmpsize);

  //printf("#include <avr/pgmspace.h>\n");
  printf("\n");

  int r,g,b;
  char *dot = strrchr(filename,'.');
  if(dot) *dot=0;
  if(bits<=8) {
    printf("const unsigned char %s[0x%04x+%d*2+6] PROGMEM = {\n",filename,bmpsize,colors);
    printf("  %d,%d,%d,%d,%d,%d,  // width,height,bits\n",w&255,w>>8,h&255,h>>8,bits&255,0);
 
    for(int i=0;i<colors;i++) {
      b = bmp[54+i*4+0];
      g = bmp[54+i*4+1];
      r = bmp[54+i*4+2];
      unsigned short c = RGBto565(r,g,b);
      printf("  0x%02x,0x%02x,      // c%03d->%3d,%3d,%3d\n",c>>8,c&255,i,r,g,b);
    }
  } else {
    printf("const unsigned short %s[0x%04x+3] PROGMEM = {\n",filename,bmpsize/2);
    printf("  %d,%d,%d,      // width,height,bits\n",w,h,bits);
  }
  //printf("offs=0x%04x\n",offs);
  printf("  ");
  int wl = w, ww = w;
  if(wl&3) wl=(w+3)&0xfffc;
  if(bits==4) { ww/=2; wl/=2; }
  long cnt = 0;
  if(bits<=8) {
    for(int j=0;j<h;j++) {
      for(int i=0;i<ww;i++) {
        if((cnt & 0xf)==0 && cnt>0) printf("\n  ");
        printf("0x%02x,",bmp[offs+i+wl*(h-j-1)]);
        cnt++;
      }
    }
  } else {
    for(int j=0;j<h;j++) {
      for(int i=0;i<w;i++) {
        b = bmp[offs+i*3+wl*3*(h-j-1)+0];
        g = bmp[offs+i*3+wl*3*(h-j-1)+1];
        r = bmp[offs+i*3+wl*3*(h-j-1)+2];
        unsigned short c = RGBto565(r,g,b);
        if((cnt & 0xf)==0 && cnt>0) printf("\n  ");
        printf("0x%04x,",c);
        cnt++;
      }
    }
  }
  printf("\n};\n");
}


